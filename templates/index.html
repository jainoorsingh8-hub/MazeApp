<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Maze Visualizer — Dark</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      --bg: #0f1724;
      --panel: #0b1220;
      --muted: #94a3b8;
      --wall: #000000;     /* walls */
      --path: #f8fafc;     /* passage */
      --start: #10b981;
      --end: #ef4444;
      --visited: #60a5fa;
      --solution: #f59e0b;
      --grid-border: #111827;
    }
    body { background: #071027; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; color: #e6eef8; }
    .container { max-width: 980px; margin: 28px auto; padding: 18px; }
    .panel { background: var(--panel); border-radius: 12px; padding: 18px; box-shadow: 0 8px 28px rgba(2,6,23,0.6); }
    .controls { display:flex; gap:12px; align-items:center; flex-wrap:wrap; justify-content:center; margin-bottom:18px; }
    .btn { padding:10px 18px; border-radius:10px; font-weight:600; cursor:pointer; }
    .btn-primary { background:#2563eb; color:white; box-shadow:0 6px 18px rgba(37,99,235,0.18); }
    .btn-ghost { background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.04); }
    .btn-success { background:#059669; color:white; }
    .btn-danger { background:#dc2626; color:white; }
    .controls .select, .controls .slider { background:transparent; color:inherit; border-radius:8px; padding:8px; }
    .layout { display:grid; grid-template-columns: 1fr 360px; gap:20px; margin-top:20px; align-items:start; }
    /* maze */
    .maze-wrap { display:flex; justify-content:center; align-items:center; padding:18px; }
    #mazeContainer { width: 680px; max-width: 92vw; aspect-ratio:1/1; background:var(--path); border-radius:12px; border: 8px solid var(--grid-border); display:flex; align-items:center; justify-content:center; box-shadow: 0 10px 30px rgba(2,6,23,0.6); }
    #mazeGrid { width: calc(100% - 12px); height: calc(100% - 12px); display:grid; gap:0; }
    .cell { box-sizing:border-box; width:100%; height:100%; }
    .cell.wall { background: var(--wall); border-radius: 0; }
    .cell.path { background: var(--path); }
    .cell.start { background: var(--start); }
    .cell.end { background: var(--end); }
    .cell.visited { background: var(--visited); }
    .cell.solution { background: var(--solution); }
    /* stats & legend */
    .stats { display:grid; gap:8px; padding:12px; }
    .stat-row { display:flex; justify-content:space-between; color:var(--muted); }
    .legend { display:grid; gap:8px; padding:12px; }
    .legend-item { display:flex; gap:8px; align-items:center; color:var(--muted); }
    .dot { width:18px; height:18px; border-radius:4px; }
    /* responsive */
    @media (max-width: 980px) {
      .layout { grid-template-columns: 1fr; }
      #mazeContainer { width: 92vw; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1 style="
  text-align:center;
  font-size:42px;
  font-weight:900;
  margin-bottom:14px;
  color:#ffffff;
  letter-spacing:1px;
  text-shadow:0 4px 12px rgba(0,0,0,0.4);
">
  Maze Algorithm Visualizer
</h1>


    <div class="panel">
      <div class="controls">
        <button id="btnNewMaze" class="btn btn-primary">New Maze</button>
        <label style="display:flex;align-items:center;gap:10px;color:var(--muted)">
          Size:
          <input id="sizeRange" type="range" min="9" max="101" step="2" value="21" class="slider" />
          <span id="sizeLabel" style="min-width:42px; text-align:center; font-weight:700;">21x21</span>
        </label>

        <label style="display:flex;align-items:center;gap:10px;color:var(--muted)">
          Delay:
          <input id="delayRange" type="range" min="0" max="200" step="5" value="20" class="slider" />
          <span id="delayLabel" style="min-width:46px; text-align:center; font-weight:700;">20ms</span>
        </label>

        <label style="display:flex;align-items:center;gap:8px;">
          <select id="algorithmSelect" class="select" style="padding:8px;border-radius:8px;background:#0b1220;border:1px solid rgba(255,255,255,0.04);color:var(--muted);">
            <option value="bfs">BFS (Shortest Path)</option>
            <option value="dfs">DFS (Path Finding)</option>
          </select>
        </label>

        <button id="btnSolve" class="btn btn-success">Start Solver ▶</button>
        <button id="btnClearPath" class="btn btn-ghost">Clear Path ⟲</button>
      </div>

      <div class="layout">
        <div class="maze-wrap panel" style="padding:12px;">
          <div id="mazeContainer">
            <div id="mazeGrid"></div>
          </div>
        </div>

        <div>
          <div class="panel stats">
            <div style="font-weight:700; color:#e6eef8; margin-bottom:6px;">Statistics</div>
            <div class="stat-row"><div>Cells Explored:</div><div id="statExplored">0</div></div>
            <div class="stat-row"><div>Path Length:</div><div id="statPathLen">0</div></div>
            <div class="stat-row"><div>Time Taken:</div><div id="statTime">0ms</div></div>
            <div class="stat-row"><div>Cells in Maze:</div><div id="statCells">0</div></div>
          </div>

          <div class="panel legend" style="margin-top:14px;">
            <div style="font-weight:700; color:#e6eef8; margin-bottom:6px;">Legend</div>
            <div class="legend-item"><div class="dot" style="background:var(--start)"></div> Start (S)</div>
            <div class="legend-item"><div class="dot" style="background:var(--end)"></div> End (E)</div>
            <div class="legend-item"><div class="dot" style="background:var(--visited)"></div> Explored Cell</div>
            <div class="legend-item"><div class="dot" style="background:var(--solution)"></div> Solution Path</div>
            <div class="legend-item"><div class="dot" style="background:var(--wall)"></div> Wall</div>
            <div class="legend-item"><div class="dot" style="background:var(--path)"></div> Unexplored Path</div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/* Frontend logic: request /api/generate_maze and /api/solve_maze,
   render grid compactly, animate visited steps and solution. */

const mazeGridEl = document.getElementById('mazeGrid');
const btnNewMaze = document.getElementById('btnNewMaze');
const btnSolve = document.getElementById('btnSolve');
const btnClearPath = document.getElementById('btnClearPath');
const sizeRange = document.getElementById('sizeRange');
const sizeLabel = document.getElementById('sizeLabel');
const delayRange = document.getElementById('delayRange');
const delayLabel = document.getElementById('delayLabel');
const algorithmSelect = document.getElementById('algorithmSelect');

const statExplored = document.getElementById('statExplored');
const statPathLen = document.getElementById('statPathLen');
const statTime = document.getElementById('statTime');
const statCells = document.getElementById('statCells');

let maze = [];
let size = parseInt(sizeRange.value);
let delayMs = parseInt(delayRange.value);
let cells = []; // flat array of cell DOM elements
let isSolving = false;

function setControlsDisabled(disabled) {
  btnNewMaze.disabled = disabled;
  btnSolve.disabled = disabled;
  btnClearPath.disabled = disabled;
  sizeRange.disabled = disabled;
  algorithmSelect.disabled = disabled;
}

// helper to sleep
const sleep = (ms) => new Promise(res => setTimeout(res, ms));

// compute cell size and draw grid
function renderGrid() {
  mazeGridEl.innerHTML = '';
  cells = [];
  const n = size;
  mazeGridEl.style.gridTemplateColumns = `repeat(${n}, 1fr)`;
  mazeGridEl.style.gridTemplateRows = `repeat(${n}, 1fr)`;
  // create cells
  for (let y = 0; y < n; y++) {
    for (let x = 0; x < n; x++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      const val = maze[y][x];
      if (val === 1) cell.classList.add('wall');
      else if (val === 2) cell.classList.add('start');
      else if (val === 3) cell.classList.add('end');
      else cell.classList.add('path');
      mazeGridEl.appendChild(cell);
      cells.push(cell);
    }
  }
  statCells.textContent = n * n;
}

// convert (x,y) -> index
function idx(x,y){ return y * size + x; }

async function fetchNewMaze(sz) {
  setControlsDisabled(true);
  try {
    const res = await fetch('/api/generate_maze', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ size: sz })
    });
    const data = await res.json();
    maze = data.maze;
    size = data.size;
    sizeLabel.textContent = `${size}x${size}`;
    renderGrid();
    clearStats();
  } catch (e) {
    alert('Failed to generate maze: ' + e);
  } finally {
    setControlsDisabled(false);
  }
}

function clearStats() {
  statExplored.textContent = '0';
  statPathLen.textContent = '0';
  statTime.textContent = '0ms';
}

// remove visited & solution classes but keep maze
function clearPathVisuals() {
  cells.forEach(c => {
    c.classList.remove('visited','solution');
    // restore start/end classes if overwritten
  });
  // ensure start/end cells style
  const startIdx = idx(1,1);
  if (cells[startIdx]) {
    cells[startIdx].classList.remove('path','visited','solution','wall'); 
    cells[startIdx].classList.add('start');
  }
  const endIdx = idx(size-2,size-2);
  if (cells[endIdx]) {
    cells[endIdx].classList.remove('path','visited','solution','wall');
    cells[endIdx].classList.add('end');
  }
  clearStats();
}

btnNewMaze.addEventListener('click', () => {
  const s = parseInt(sizeRange.value);
  fetchNewMaze(s);
});

btnClearPath.addEventListener('click', () => {
  clearPathVisuals();
});

sizeRange.addEventListener('input', (e) => {
  sizeLabel.textContent = `${e.target.value}x${e.target.value}`;
});

delayRange.addEventListener('input', (e) => {
  delayMs = parseInt(e.target.value);
  delayLabel.textContent = `${delayMs}ms`;
});

// solve and animate
btnSolve.addEventListener('click', async () => {
  if (!maze || maze.length === 0) {
    alert('Please generate a maze first.');
    return;
  }
  if (isSolving) return;
  isSolving = true;
  setControlsDisabled(true);
  clearPathVisuals();

  const algorithm = algorithmSelect.value;
  try {
    const res = await fetch('/api/solve_maze', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ maze: maze, algorithm: algorithm })
    });
    const data = await res.json();

    const visited = data.visited_steps || [];
    const path = data.path || [];
    statExplored.textContent = data.explored ?? visited.length;
    statPathLen.textContent = path.length ?? 0;
    statTime.textContent = (data.time ?? 0) + 'ms';

    // animate visited
    for (let i = 0; i < visited.length; i++) {
      const [x,y] = visited[i];
      const el = cells[idx(x,y)];
      if (!el) continue;
      if (!el.classList.contains('start') && !el.classList.contains('end')) {
        el.classList.add('visited');
      }
      if (delayMs > 0) await sleep(delayMs);
    }
    // animate path
    for (let i = 0; i < path.length; i++) {
      const [x,y] = path[i];
      const el = cells[idx(x,y)];
      if (!el) continue;
      el.classList.remove('visited');
      if (!el.classList.contains('start') && !el.classList.contains('end')) {
        el.classList.add('solution');
      }
      if (delayMs > 0) await sleep(Math.max(10, delayMs));
    }

  } catch (err) {
    alert('Solver failed: ' + err);
  } finally {
    isSolving = false;
    setControlsDisabled(false);
  }
});

// initial generate
window.addEventListener('load', () => {
  size = parseInt(sizeRange.value);
  delayMs = parseInt(delayRange.value);
  sizeLabel.textContent = `${size}x${size}`;
  delayLabel.textContent = `${delayMs}ms`;
  fetchNewMaze(size);
});
</script>
</body>
</html>
